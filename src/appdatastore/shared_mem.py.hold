#!/usr/bin/env python3
'''
Datastore - Shared Mem

Copyright (C) 2025 Jason Piszcyk
Email: Jason.Piszcyk@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program (See file: COPYING). If not, see
<https://www.gnu.org/licenses/>.
'''
###########################################################################
#
# Imports
#
###########################################################################
from __future__ import annotations

# Shared variables, constants, etc

# System Modules
import sys
import multiprocessing
from multiprocessing.shared_memory import SharedMemory

from appcore.helpers import timestamp
from appcore.conversion import to_json, from_json, to_pickle, from_pickle

# Local app modules
from appdatastore.base import DataStoreBaseClass
from appdatastore.typing import SerialisationType

# Imports for python variable type hints
from typing import Any
from multiprocessing.synchronize import Lock as LockType

###########################################################################
#
# Module Specific Items
#
###########################################################################
#
# Types
#


#
# Constants
#
DEFAULT_SHARED_MEM_NAME = "AppDataStore_SharedMem"
DEFAULT_INDEX_SIZE = 16384      # 16K


#
# Global Variables
#


###########################################################################
#
# DataStoreSharedMem Class Definition
#
###########################################################################
class DataStoreSharedMem(DataStoreBaseClass):
    '''
    Class to describe the shared memory datastore.

    The data is stored in a dictionary that is made available via shared memory

    Attributes:
        name (str) [ReadOnly]: Name of the shared memory segment
    '''
    #
    # __init__
    #
    def __init__(
            self,
            *args,
            name: str = "",
            encrypt_index: bool = False,
            index_size: int = DEFAULT_INDEX_SIZE,
            **kwargs
    ):
        '''
        Initialises the instance.

        Args:
            *args (Undef): Unnamed arguments to be passed to the constructor
                of the inherited process
            name (str): Name of the shared memory segment to create or
                connect to
            encrypt_index (bool): If true, encrypt the index.  Password must
                be provided or a random password will be used and no other
                processes can access the shared memory datastore
            **kwargs (Undef): Keyword arguments to be passed to the constructor
                of the inherited process

        Returns:
            None

        Raises:
            AssertionError
                When name is not a string
                When encrypt_index is not a bool
            TypeError
                When share memory creation fails
        '''
        assert isinstance(name, str), "name must be a string"
        assert isinstance(encrypt_index, bool), "encrypt_index must be a bool"

        super().__init__(*args, **kwargs)

        # Private Attributes
        self._name = name or DEFAULT_SHARED_MEM_NAME
        self._encrypt_index = encrypt_index
        self._lock = None
        self._lock_name = f"{name}_lock"
        self._lock_segment = None
        self._index_name = f"{name}_index"
        self._index_segment = None

        if index_size > DEFAULT_INDEX_SIZE:
            self._index_size = index_size
        else:
            self._index_size = DEFAULT_INDEX_SIZE

        # Always store values serialised (Shared mem stores bytes)
        self._store_serialised = True
        self._serialisation_method = SerialisationType.PICKLE

        # Attributes

        #
        # Get or create the lock segment
        #
        _temp_lock = multiprocessing.Lock()
        self._lock_segment, _created = self._fast_open_or_create_shm(
            name = self._lock_name,
            size = sys.getsizeof(_temp_lock)
        )

        if _created:
            # Store the lock info
            self._fast_set_shm(
                shm=self._lock_segment,
                value=_temp_lock,
                encrypt=self._encrypt_index
            )

            self._lock = _temp_lock

        else:
            # Get the lock info
            self._lock = self._fast_get_shm(
                shm=self._lock_segment,
                decrypt=self._encrypt_index
            )

        # Close the lock segment as we won't need this again
        self._lock_segment.close()


        #
        # Get or create the index segment
        #
        self._index_segment, _created = self._fast_open_or_create_shm(
            name = self._index_name,
            size = self._index_size
        )

        if _created:
            # Store a default index
            self._fast_set_shm(
                shm=self._index_segment,
                value={},
                encrypt=self._encrypt_index
            )


    ###########################################################################
    #
    # Properties
    #
    ###########################################################################
    #
    # name
    #
    @property
    def name(self) -> str:
        ''' The name of the shared memory segment '''
        return self._name


    ###########################################################################
    #
    # Shared Mem Access Functions
    #
    ###########################################################################
    #
    # _fast_open_or_create_shm
    #
    def _fast_open_or_create_shm(
            self,
            name: str = "",
            size: int = 0
    ) -> tuple[SharedMemory, bool]:
        '''
        Open the shared memory segment or create it if necessary

        Args:
            name (str): Name of the shared memory segment to check
            size (int): The size of the shared memory segment if being created

        Returns:
            SharedMemory: The required shared memory segment
            bool: True if the segment ewas created, false if already existed

        Raises:
            AssertionError
                When name is not a string
                When sized is not an integer
        '''
        assert isinstance(name, str), "name must be a string"
        assert isinstance(size, int), "size must be an integer"

        try:
            _shm = SharedMemory(name=name, create=False)
            return _shm, False

        except FileNotFoundError:
            pass

        # Segment does not exist, create it
        _new_shm = SharedMemory(name=name, create=True, size=size)

        return _new_shm, True


    #
    # _ds_shm_exists
    #
    def _ds_shm_exists(self, name: str = "") -> bool:
        '''
        Check if the named shared memory segment exists (for Datastore mode)

        Args:
            name (str): Name of the shared memory segment to check

        Returns:
            bool: True if the segment exists, false otherwise

        Raises:
            AssertionError
                When name is not a string
        '''
        assert isinstance(name, str), "name must be a string"

        try:
            _shm = SharedMemory(name=name, create=False)
            _shm.close()
            return True

        except FileNotFoundError:
            pass

        return False


    #
    # _fast_get_shm
    #
    def _fast_get_shm(
            self,
            shm: SharedMemory | None = None,
            decrypt: bool = False
    ) -> Any:
        '''
        Get a value from the named shared memory segment (Fast mode)

        Args:
            shm (SharedMemory): The shared memory segment to read
            decrypt (bool): whether or not the value needs to be decrypted

        Returns:
            Any: The stored value

        Raises:
            AssertionError
                When name is not a string
                When the shared memory buffer is not accessible
            FileNotFoundError
                When the shared memory segment cannot be found
        '''
        assert isinstance(shm, SharedMemory), "shm must be SharedMemory"
        assert isinstance(shm.buf, memoryview), (
            "unable to process shared memory configuration"
        )

        return self._decode(value=shm.buf.tobytes(), decrypt=decrypt)


    #
    # _ds_get_shm
    #
    def _ds_get_shm(
            self,
            name: str = "",
            decrypt: bool = False
    ) -> Any:
        '''
        Get a value from the named shared memory segment (Datastore mode)

        Args:
            name (str): Name of the shared memory segment to read
            decrypt (bool): whether or not the value needs to be decrypted

        Returns:
            Any: The stored value

        Raises:
            AssertionError
                When name is not a string
                When the shared memory buffer is not accessible
            FileNotFoundError
                When the shared memory segment cannot be found
        '''
        assert isinstance(name, str), "name must be a string"
        name = name or DEFAULT_SHARED_MEM_NAME

        _shm = SharedMemory(name=name, create=False)
        _val = self._fast_get_shm(shm=_shm, decrypt=decrypt)
        _shm.close()

        return _val


    #
    # _fast_set_shm
    #
    def _fast_set_shm(
            self,
            shm: SharedMemory | None = None,
            value: Any = None,
            encrypt: bool = False
    ):
        '''
        Set a value in the named shared memory segment (Fast mode)

        Args:
            shm (SharedMemory): The shared memory segment to set
            value (Any): Value to be stored
            encrypt (bool): whether or not the value needs to be encrypted

        Returns:
            None

        Raises:
            AssertionError
                When name is not a string
                When the shared memory buffer is not accessible
            ValueError
                When value is too big to be stored in the shared memory segment
        '''
        assert isinstance(shm, SharedMemory), "shm must be SharedMemory"
        assert isinstance(shm.buf, memoryview), (
            "unable to process shared memory configuration"
        )

        _encoded_val = self._encode(value=value, encrypt=encrypt)
        _val_size = sys.getsizeof(_encoded_val)

        if _val_size > shm.size:
            raise ValueError("value is too big for shared memory segment")

        # Write to the segment and zero out the rest of it
        shm.buf[:_val_size] = _encoded_val
        if _val_size < shm.size:
            shm.buf[_val_size:] = b'\x00' * (shm.size - _val_size)


    #
    # _ds_set_shm
    #
    def _ds_set_shm(
            self,
            name: str = "",
            value: Any = None,
            encrypt: bool = False
    ):
        '''
        Set a value in the named shared memory segment (Datastore mode)

        Args:
            name (str): Name of the shared memory segment to write
            value (Any): Value to be stored
            encrypt (bool): whether or not the value needs to be encrypted

        Returns:
            None

        Raises:
            AssertionError
                When name is not a string
                When the shared memory buffer is not accessible
        '''
        assert isinstance(name, str), "name must be a string"
        name = name or DEFAULT_SHARED_MEM_NAME

        # Encode the value, and get the size
        _encoded_val = self._encode(value=value, encrypt=encrypt)
        _val_size = sys.getsizeof(_encoded_val)

        _create_shm = False
        _shm = None
        try:
            _shm = SharedMemory(name=name, create=False)

        except FileNotFoundError:
            _create_shm = True

        if _create_shm:
            _shm = SharedMemory(name=name, create=True, size=_val_size)

        # Store the value
        if not isinstance(_shm, SharedMemory):
            raise MemoryError(
                "unable to access shared memory"
            )

        if not isinstance(_shm.buf, memoryview):
            raise MemoryError(
                "unable to process shared memory configuration"
            )

        _shm.buf[:_val_size] = _encoded_val
        if _val_size < _shm.size:
            _shm.buf[_val_size:] = b'\x00' * (_shm.size - _val_size)

        _shm.close()


    ###########################################################################
    #
    # Locking Functions
    #
    ###########################################################################
    #
    # _acquire_lock
    #
    def _acquire_lock(self):
        '''
        Acquire the lock for shared memory actions

        Args:
            None

        Returns:
            None

        Raises:
            None
        '''
        if isinstance(self._lock, LockType):
            self._lock.acquire()
        else:
            self._logger.warning("Unable to acquire lock")


    #
    # _release_lock
    #
    def _release_lock(self):
        '''
        Release the lock

        Args:
            None

        Returns:
            None

        Raises:
            None
        '''
        if isinstance(self._lock, LockType):
            self._lock.release()
        else:
            self._logger.warning("Unable to release lock")


    ###########################################################################
    #
    # Indexing Functions
    #
    ###########################################################################
    #
    # _get_index
    #
    def _get_index(self) -> dict:
        '''
        Get the shared index

        Args:
            None

        Returns:
            None

        Raises:
            TypeError
                When there is a problem with the index
        '''
        # Get the index
        _index = self._fast_get_shm(
            shm=self._index_segment,
            decrypt=self._encrypt_index
        )

        if not isinstance(_index, dict):
            raise TypeError("index is corrupt")

        return _index


    #
    # _add_to_index
    #
    def _add_to_index(self, name:str = "", timeout:int = 0):
        '''
        Add a name to the shared index.

        Args:
            name (str): Name of the shared memory segment to write
            timeout (int): The number of seconds before the item should be
                deleted (0 = never delete)

        Returns:
            None

        Raises:
            AssertionError
                When name is empty or not a string
        '''
        assert isinstance(name, str), "name must be a string"
        assert name, "name must contain a value"

        self._acquire_lock()

        # Get the index
        _index = self._get_index()

        # Add the name
        _entry = {
            "lock": multiprocessing.Lock(),
            "timeout": timeout
        }
        _index[name] = _entry

        # Store the new index
        self._fast_set_shm(
            shm=self._index_segment,
            value=_index,
            encrypt=self._encrypt_index
        )

        self._release_lock()


    #
    # _del_from_index
    #
    def _del_from_index(self, name:str = ""):
        '''
        Add a name to the shared index

        Args:
            name (str): Name of the shared memory segment to write

        Returns:
            None

        Raises:
            AssertionError
                When name is empty or not a string
        '''
        assert isinstance(name, str), "name must be a string"
        assert name, "name must contain a value"

        self._acquire_lock()

        # Get the index
        _index = self._get_index()

        # Remove the name
        if name in _index.keys():
            del _index[name]

            # Store the new index
            self._fast_set_shm(
                shm=self._index_segment,
                value=_index,
                encrypt=self._encrypt_index
            )

        self._release_lock()


    ###########################################################################
    #
    # Maintenance Functions
    #
    ###########################################################################
    #
    # maintenance
    #
    def maintenance(self):
        '''
        Perform maintenance on items (such as expiry)

        Args:
            None

        Returns:
            None

        Raises:
            None
        '''
        self._logger.debug("Start item maintenance")

        if self._manual_expiry:
            self._logger.debug("Begin manual expiry processing")

            # # Process the expiry list
            # _now = timestamp()
            # _sorted_expiry_list = sorted(self._data_expiry)

            # # Use the copy of __data_expiry list as it can change it during
            # # processing
            # for _entry in _sorted_expiry_list:
            #     # Extract the timestamp from the key
            #     _timestamp_str, _, _name = str(_entry).partition("__")
            #     _timestamp = set_value(
            #         data=_timestamp_str,
            #         type=DataType.INT,
            #         default=0
            #     )

            #     # Stop processing if the timestamp is in the future
            #     if _now < _timestamp: break

            #     # Remove the entry (and the expiry record)
            #     self._logger.info(f"Expiring entry: {self._data[_name]}")
            #     self._lock.acquire()
            #     if _name in self._data: del self._data[_name]
            #     self._data_expiry.remove(_entry)
            #     self._lock.release()

            self._logger.debug("End manual expiry processing")


        self._logger.debug("End item maintenance")


    #
    # cleanup
    #
    def cleanup(self):
        '''
        Close and unlink all of the shared memory segments we know about

        Args:
            None

        Returns:
            None

        Raises:
            None
        '''
        self._logger.debug("Start shared memory cleanup")

        # Get the lock to prevent any changes
        self._acquire_lock()

        # Get the index
        _index_closed = False
        _index = None
        try:
            _index = self._fast_get_shm(
                shm=self._index_segment,
                decrypt=self._encrypt_index
            )

        except FileNotFoundError:
            # Index already closed
            _index_closed = True
            self._index_segment = None

        if not _index_closed and isinstance(_index, dict):
            # Go through the index and close/unlink all segments
            for _name in _index.keys():
                # Close/Unlink the named segment
                try:
                    _segment = SharedMemory(
                        name=_name,
                        create=False
                    )
                    _segment.close()
                    _segment.unlink()

                except FileNotFoundError:
                    # Segment does not exist!
                    pass

            # Close/Unlink the index segment
            try:
                if isinstance(self._index_segment, SharedMemory):
                    self._index_segment.close()
                    self._index_segment.unlink()

            except FileNotFoundError:
                # Segment does not exist!
                pass

            self._index_segment = None

        # Release the lock as it is about to be deleted
        self._release_lock()

        # Close/Unlink the lock segment
        if isinstance(self._lock_segment, SharedMemory):
            try:
                self._lock_segment.close()
                self._lock_segment.unlink()

            except FileNotFoundError:
                # Segment is already unlinked
                pass

        self._lock_segment = None
        self._lock = None

        self._logger.debug("End shared memory cleanup")


    ###########################################################################
    #
    # Data Access
    #
    ###########################################################################
    #
    # has
    #
    def has(
            self,
            name: str = ""
    ) -> bool:
        '''
        Check if the item exists in the datastore

        Args:
            name (str): The name of the item to check

        Returns:
            bool: True if the item exists, False otherwise

        Raises:
            AssertionError
                When cannot access shared memory
                When the shared memory buffer is not accessible
        '''
        self.maintenance()

        # Get the index
        _index = self._get_index()

        # Get the id of the mem segment that holds the index
        return name in _index.keys()


    #
    # get
    #
    def get(
            self,
            name: str = "",
            default: Any = None,
            decrypt: bool = False
    ) -> Any:
        '''
        Get a value (Datastore mode)

        Args:
            name (str): The name of the item to get
            default (Any): Value to return if the item cannot be found
            decrypt (bool): If True, attempt to decrypt the value

        Returns:
            Any: The value of the item

        Raises:
            None
        '''
        if not self.has(name=name): return default

        return self._ds_get_shm(name=name, decrypt=decrypt)


    #
    # get_fast
    #
    def get_fast(
            self,
            shm: SharedMemory | None = None,
            default: Any = None,
            decrypt: bool = False
    ) -> Any:
        '''
        Get a value (Fast Mode)

        Args:
            shm (SharedMemory): The shared memory segment to read
            default (Any): Value to return if the item cannot be found
            decrypt (bool): If True, attempt to decrypt the value

        Returns:
            Any: The value of the item

        Raises:
            None
        '''
        try:
            _val = self._fast_get_shm(shm=shm, decrypt=decrypt)

        except AssertionError:
            _val = default

        return _val


    #
    # set
    #
    def set(
            self,
            name: str = "",
            value: Any = None,
            encrypt: bool = False,
            timeout: int = 0
    ) -> None:
        '''
        Set a value for an item (Datastore mode)

        Args:
            name (str): The name of the item to set
            value (Any): Value to set the item to
            encrypt (bool): If True, attempt to encrypt the value
            timeout (int): The number of seconds before the item should be
                deleted (0 = never delete)

        Returns:
            None

        Raises:
            AssertionError:
                When timeout is not zero or a positive integer
            KeyError:
                When the dot name is a low part of a hierarchy
        '''
        assert isinstance(timeout, int), "Timeout value must be an integer"
        assert timeout >= 0, "Timeout value must be a postive integer"

        self.maintenance()

        # Check on dot names
        if self._dot_names:
            _keys = list(self._data.keys())
            if not self._check_dot_name(keys=_keys, name=name):
                raise KeyError(
                    "Value cannot be stored in a intermediate dot level name"
                )

        # Get the index
        _index = self._get_index()
        _add_index_entry = False

        if name in _index.keys():
            # If a timeout is provided, update the index
            if timeout > 0:
                self._del_from_index(name=name)
                _add_index_entry = True

        else:
            _add_index_entry = True

        if _add_index_entry: self._add_to_index(name=name, timeout=timeout)

        # Re-read the index to get updates, then get the lock
        _index = self._get_index()
        _lock = None

        if name in _index.keys():
            # Get the lock for the shared mem segment for this item
            if not "lock" in _index[name]:
                raise TypeError("index missing lock for item")
            
            _lock = _index[name]["lock"]

        if not isinstance(_lock, LockType):
            raise TypeError("item lock is not valid")

        # Set the value
        _lock.acquire()
        self._ds_set_shm(name=name, value=value, encrypt=encrypt)
        _lock.release()


    #
    # set_fast
    #
    def set_fast(
            self,
            shm: SharedMemory | None = None,
            value: Any = None,
            encrypt: bool = False,
            timeout: int = 0
    ) -> None:
        '''
        Set a value for an item (Fast mode)

        Args:
            shm (SharedMemory): The shared memory segment to read
            value (Any): Value to set the item to
            encrypt (bool): If True, attempt to encrypt the value
            timeout (int): The number of seconds before the item should be
                deleted (0 = never delete)

        Returns:
            None

        Raises:
            AssertionError:
                When timeout is not zero or a positive integer
                When the shared memory buffer is not accessible
            KeyError:
                When the dot name is a low part of a hierarchy
        '''
        assert isinstance(timeout, int), "Timeout value must be an integer"
        assert timeout >= 0, "Timeout value must be a postive integer"

        assert isinstance(shm, SharedMemory), "shm must be SharedMemory"
        assert isinstance(shm.buf, memoryview), (
            "unable to process shared memory configuration"
        )

        # Check on dot names
        if self._dot_names:
            _keys = list(self._data.keys())
            if not self._check_dot_name(keys=_keys, name=shm.name):
                raise KeyError(
                    "Value cannot be stored in a intermediate dot level name"
                )

        # Get the index
        _index = self._get_index()
        _add_index_entry = False

        if shm.name in _index.keys():
            # If a timeout is provided, update the index
            if timeout > 0:
                self._del_from_index(name=shm.name)
                _add_index_entry = True

        else:
            _add_index_entry = True

        if _add_index_entry: self._add_to_index(name=shm.name, timeout=timeout)

        # Re-read the index to get updates, then get the lock
        _index = self._get_index()
        _lock = None

        if shm.name in _index.keys():
            # Get the lock for the shared mem segment for this item
            if not "lock" in _index[shm.name]:
                raise TypeError("index missing lock for item")
            
            _lock = _index[shm.name]["lock"]

        if not isinstance(_lock, LockType):
            raise TypeError("item lock is not valid")

        # Set the value
        _lock.acquire()
        self._fast_set_shm(shm=shm, value=value, encrypt=encrypt)
        _lock.release()


    #
    # delete
    #
    def delete(
            self,
            name: str = ""
    ) -> None:
        '''
        Delete an item from the datastore

        Args:
            name (str): The name of the item to delete

        Returns:
            Any: The value of the item

        Raises:
            None
        '''
        if self.has(name):
            # self._lock.acquire()
            # del self._data[name]
            self._lock.release()


    #
    # list
    #
    def list(
            self,
            prefix: str = ""
    ) -> list:
        '''
        Return a list of keys in the datastore

        Args:
            prefix (str): Will try to match any keys beginning with this str.

        Returns:
            list: The list of items

        Raises:
            None
        '''
        self.maintenance()
        _key_list = list(self._data.keys())
 
        return self._filter_keys(keys=_key_list, prefix=prefix)


    ###########################################################################
    #
    # Export Functions
    #
    ###########################################################################
    #
    # export_to_json
    #
    def export_to_json(
            self,
            container: bool = True
    ) -> str:
        '''
        Export the data store to JSON

        Args:
            container (bool): If true, the export contains an outer layer:
                {
                    "value": { The export values },
                    "type": "dictionary"
                }

        Returns:
            str: The JSON string

        Raises:
            None
        '''
        # Convert to JSON
        self._logger.debug("Exporting Datastore to JSON")
        _export_data = {}

        # Transform the data to a straight dict
        _key_list = sorted(list(self._data.keys()))

        # for _key in _key_list:
        #     # If dot names, handle the hierarchy
        #     if self._dot_names:
        #         _rest = _key
        #         _cur_level = _export_data

        #         while _rest:
        #             # Split the name to get the first level (and the rest)
        #             # If no dot in the name, then _rest will be empty
        #             (_level, _, _rest) = _rest.partition(".")

        #             if not _rest:
        #                 # This is the item name
        #                 _cur_level[_level] = self.get(_key)
        #                 continue

        #             elif not _level in _cur_level:
        #                 _cur_level[_level] = {}

        #             # Move on to the next level
        #             _cur_level = _cur_level[_level]

        #     else:
        #         _export_data[_key] = self.get(_key)

        return to_json(
            data=_export_data,
            skip_invalid=True,
            container=container
        )


###########################################################################
#
# In case this is run directly rather than imported...
#
###########################################################################
'''
Handle case of being run directly rather than imported
'''
if __name__ == "__main__":
    pass
